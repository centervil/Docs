# コーディング規約

このドキュメントは、プロジェクトにおけるコーディング規約とベストプラクティスを定義します。これらのルールは、コードの一貫性、可読性、保守性を向上させるために設計されています。

## 1. 命名規則

### 1.1 ファイル名
- Pythonファイル: スネークケース（例: `file_name.py`）
- マークダウンファイル: スネークケース（例: `document_name.md`）
- テストファイル: `test_` で始める（例: `test_module.py`）

### 1.2 変数名
- 変数名: スネークケース（例: `variable_name`）
- 定数: 大文字のスネークケース（例: `CONSTANT_VALUE`）
- プライベート変数: アンダースコアで始める（例: `_private_var`）

### 1.3 クラス名
- クラス名: パスカルケース（例: `ClassName`）
- メソッド名: スネークケース（例: `method_name`）

### 1.4 関数名
- 関数名: スネークケース（例: `function_name`）
- 関数名は動詞で始める（例: `get_data()`, `process_file()`）

## 2. コードスタイル

### 2.1 インデント
- 4スペースを使用する
- タブは使用しない

### 2.2 行の長さ
- 1行は最大88文字
- 長い行は適切に折り返す

### 2.3 インポート
- 標準ライブラリ、サードパーティライブラリ、ローカルモジュールの順に記述し、それぞれをブロックで分ける
- アルファベット順にソートする
- ワイルドカードインポート（`from module import *`）は避ける

```python
# 例
import os
import sys

import requests
from dotenv import load_dotenv

from app.utils import helper
```

### 2.4 ドキュメンテーション
- すべての関数、クラス、モジュールにはdocstringを付ける
- Google形式のdocstringを使用する

```python
def function_name(param1, param2):
    """関数の簡潔な説明。

    より詳細な説明（必要な場合）。

    Args:
        param1 (int): 最初のパラメータの説明
        param2 (str): 2番目のパラメータの説明

    Returns:
        bool: 戻り値の説明

    Raises:
        ValueError: エラーの説明
    """
    pass
```

## 3. 開発スタイル

### 3.1 設計原則
- **DRY (Don't Repeat Yourself)**: コードの重複を避け、再利用可能なコンポーネントを作成する
  - 同じコードが2回以上出現した場合は、関数化またはクラス化を検討する
  - 設定値やマジックナンバーは定数として定義する
  - ユーティリティ関数は専用モジュールに集約する

- **SOLID原則**: オブジェクト指向設計の基本原則を遵守する
  - 単一責任の原則 (Single Responsibility Principle)
    - 各クラスは明確に定義された単一の責任を持つべき
  - オープン・クローズドの原則 (Open/Closed Principle)
    - コードは拡張に対しては開かれ、修正に対しては閉じられているべき
  - リスコフの置換原則 (Liskov Substitution Principle)
    - サブクラスは基底クラスと置き換え可能であるべき
  - インターフェース分離の原則 (Interface Segregation Principle)
    - クライアントは不要なインターフェースに依存すべきでない
  - 依存性逆転の原則 (Dependency Inversion Principle)
    - 抽象化に依存し、具象に依存しないようにする

### 3.2 開発プロセス
- **テスト駆動開発 (TDD)**
  - 新機能の実装前にテストを先に書く
  - 「赤（テスト失敗）→緑（テスト成功）→リファクタリング」のサイクルに従う
  - テストカバレッジは80%以上を目標とする
  - 単体テスト、統合テスト、エンドツーエンドテストをバランスよく実装する

- **継続的なリファクタリング**
  - コードの品質低下を防ぐため、定期的にリファクタリングを行う
  - 「ボーイスカウトルール」: コードを以前よりもきれいな状態で残す
  - 技術的負債は早期に解消する
  
- **コードレビュー**
  - すべての変更はレビューを受ける
  - レビューでは機能性だけでなく、このコーディング規約への準拠も確認する
  - 知識共有の機会としてレビューを活用する

### 3.3 Docker環境での開発
- **コンテナファースト**
  - すべての開発・テスト・本番環境はDockerコンテナで統一する
  - ローカル環境での直接実行は避け、常にコンテナ内で動作確認する
  - `docker-compose.yml`ファイルで開発環境を定義し、共有する

- **環境の一貫性**
  - 開発、テスト、ステージング、本番環境はできるだけ同じ構成にする
  - 環境の違いは環境変数で制御し、コード変更は不要にする
  - イメージのビルドプロセスを標準化し、一貫性を確保する

- **CI/CDとの統合**
  - GitHub Actionsなどのツールを使い、コンテナビルドからデプロイまでを自動化する
  - テスト、静的解析、セキュリティスキャンをCI/CDパイプラインに組み込む
  - コンテナイメージのバージョン管理を徹底する

## 4. エラーハンドリング

### 4.1 例外処理
- 具体的な例外型をキャッチする（`except Exception:`ではなく`except ValueError:`など）
- 例外を握りつぶさない（空の`except`ブロックは避ける）
- コンテキストマネージャ（`with`文）を適切に使用する

### 4.2 ログ記録
- `print`ではなく、`logging`モジュールを使用する
- 適切なログレベルを使用する（DEBUG, INFO, WARNING, ERROR, CRITICAL）
- 例外発生時は、スタックトレースも記録する

## 5. テスト

### 5.1 テスト戦略
- すべての公開関数とメソッドに単体テストを書く
- モックやスタブを適切に使用する
- 境界値のテストケースを含める

### 5.2 テストツール
- `pytest`を使用する
- テストカバレッジレポートを生成する
- CI/CDパイプラインでテストを自動化する

## 6. バージョン管理

### 6.1 コミットメッセージ
- 簡潔で具体的なコミットメッセージを書く
- 現在形を使用する（"Fixed bug"ではなく"Fix bug"）
- 必要に応じて詳細な説明を追加する

### 6.2 ブランチ戦略
- 機能開発は`feature/`で始まるブランチで行う
- バグ修正は`bugfix/`で始まるブランチで行う
- リリース準備は`release/`で始まるブランチで行う

## 7. セキュリティ

### 7.1 機密情報
- ハードコードされたシークレットや認証情報はコードに含めない
- 環境変数や設定ファイルを使用する
- `.env`ファイルはバージョン管理から除外する

### 7.2 入力検証
- すべてのユーザー入力を検証する
- SQLインジェクションや他の一般的な攻撃ベクトルを防止する

## 8. パフォーマンス

### 8.1 リソース管理
- ファイルやネットワーク接続などのリソースは使用後に必ず閉じる
- メモリ使用量を監視し、大きなオブジェクトは適切に解放する

### 8.2 アルゴリズム効率
- 処理時間とメモリ使用量のバランスを考慮する
- 計算量の高い処理は最適化する

## 9. ドキュメンテーション

### 9.1 プロジェクトドキュメント
- READMEファイルにプロジェクトの概要、セットアップ手順、使用例を記載する
- API仕様書を維持する
- 変更履歴を記録する

### 9.2 コードドキュメント
- コードの複雑な部分には適切なコメントを追加する
- 「なぜ」そのコードが必要なのかを説明する（「何を」しているかは良いコードから明らかであるべき）

## 10. コード品質

### 10.1 静的解析
- `flake8`、`pylint`、`mypy`などの静的解析ツールを使用する
- `.flake8`、`.pylintrc`などの設定ファイルをプロジェクトルートに配置する

### 10.2 コードレビュー
- すべてのコード変更はレビューを受ける
- コードレビューではこの規約に準拠しているかを確認する 