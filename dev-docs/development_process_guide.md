# 開発プロセスガイド (PM主導 & AIエージェント実行)

このドキュメントは、人間がプロジェクトマネージャー (PM) としてAIコーディングエージェント (Cursor, Cline, MCPなど) に指示を出す開発体制におけるプロセスとベストプラクティスを定義します。PMは開発目標とタスクの概要 (Issue) を定義し、AIエージェントにその実現を指示します。AIエージェントは自律的に設計・実装・テストを行い、PMは主要なマイルストーンやPull Requestの段階でレビュー・承認を行います。テスト駆動開発（TDD）、GitHub Flow、CI/CDパイプラインを中心とし、PMの戦略的ガイダンスのもとで、AIエージェントが高品質なコードを効率的に生成・修正・提案することを目指します。

## 1. 開発スタイル (PMによる戦略的指示とAIによる自律的実行)

### 1.1 設計原則の適用 (AIによる提案とPMによる承認)

AIエージェントはコード生成やリファクタリングを行う際、以下の設計原則を考慮し、必要に応じて適用案をPMに提示します。PMはAIからの提案をレビューし、承認または修正指示を与えます。

- **DRY (Don't Repeat Yourself)**: AIは冗長なコードを検出し、共通化するリファクタリング案を提示します。
  - 例: AI「既存の `utils.py` の `calculate_value` 関数と同様のロジックを発見しました。この関数を利用するようにリファクタリングしますか？」 PM「承認します。」
- **SOLID原則**: AIは、特に複雑なクラスやモジュールの設計・実装時にこれらの原則を考慮し、改善案を提示します。
  - 例: AI「`OrderProcessor` クラスは現在、注文処理、通知、在庫更新の責務を持っています。単一責任の原則に基づき、通知と在庫更新のロジックを別のクラスに分割することを提案します。クラス図と依存関係を示します。[図/説明]」 PM「通知ロジックのみ分割してください。」

### 1.2 開発プロセス (PM指示 -> AI自律実行 -> PMレビュー)

- **テスト駆動開発 (TDD)**: PMが機能要件 (Issue) を示し、AIエージェントがTDDサイクルを自律的に実行します。PMは重要な節目 (例: 主要なテストパス、リファクタリング完了時) でレビューを行います。
  - **PM指示**: 「[Issue #123] の仕様に基づき、`module.py` に `new_feature` 機能を実装してください。TDDサイクルに従い、テストカバレッジ80%以上を目指してください。」
  - **AI自律実行**: AIは以下のサイクルを実行し、進捗を報告します。
    1.  **Red**: 仕様に基づき、失敗するテストコードを `tests/unit/test_module.py` に生成。
    2.  **Green**: テストがパスする最小限の実装コードを `module.py` に生成。
    3.  **Refactor**: テストをパスしたまま、実装コードとテストコードの可読性・効率性を改善。
    4.  **Coverage**: カバレッジを確認し、不足していればテストケースを追加。
  - **PMレビュー**: AIからの完了報告またはマイルストーン報告を受け、PMはコード (特にインターフェースや重要ロジック) とテスト結果をレビューします。必要であれば修正指示を出します。
    - 例: PM「カバレッジレポートを確認しました。エッジケース `X` のテストが不足しています。追加してください。」 AI「承知しました。テストを追加し、再度実行します。」

- **継続的なリファクタリング**: AIエージェントは、静的解析ツールの結果やコードの複雑度に基づき、自律的にリファクタリング案を生成し、PMに提案します。PMは提案を承認するか、指示を与えます。
  - 例: AI「`complex_module.py` のサイクロマティック複雑度が閾値を超えています。リファクタリング案を以下に示します。[提案内容]」 PM「提案内容で進めてください。」
  - PMは必要に応じて、「ボーイスカウトルール」の考え方に基づき、「このファイルの可読性を改善してください」といった、より抽象的な指示を出すことも可能です。

- **コードレビュー (PMによるPull Requestレビュー)**: AIエージェントがIssueに対応する開発を完了したら、Pull Request (PR) を作成します。PMはPRをレビューし、承認または修正依頼を行います。
  - レビュー観点: 機能要件の充足、設計の妥当性、テストの網羅性、潜在的なバグ、セキュリティリスク、指示との整合性。
  - 問題があれば、PMはPRにコメントし、AIに修正を指示します。AIは指示に基づき修正し、再度Pushします。承認されるまでこのサイクルを繰り返します。

### 1.3 ブランチ戦略 (GitHub Flow)

開発はGitHub Flowに従います。AIエージェントは以下のルールでブランチを操作します。

1.  **`main` ブランチ**: 常にデプロイ可能な安定した状態を保ちます。直接コミットは禁止です。
2.  **機能ブランチ**: 新機能開発やバグ修正は、必ず `main` ブランチから作成された機能ブランチ (例: `feature/add-login`, `fix/issue-123`) で行います。
    - PMがIssueを作成・指示すると、AIエージェントはそのIssueに対応する機能ブランチを自動的に作成します。
3.  **Pull Request**: 機能ブランチでの開発が完了したら、AIエージェントは `main` ブランチへのPull Requestを作成します。
4.  **レビューとマージ**: PMがPull Requestをレビューし、承認します。承認後、PM (または設定によってはAI) が機能ブランチを `main` ブランチにマージします。
5.  **デプロイ**: `main` ブランチへのマージをトリガーとして、CI/CDパイプラインが自動的にデプロイを実行します。
6.  **ブランチ削除**: マージ後、機能ブランチは削除されます。

### 1.4 Docker環境での開発 (AIによる自律的な環境利用)

開発環境とCI/CD環境の一貫性を保つため、Dockerを使用します。AIエージェントは、PMからの明示的な指示なしに、定義されたDocker環境 (`docker-compose.yml` など) を自律的に利用して、コーディング、テスト実行、コマンド実行を行います。

- **コンテナ内操作の自動化**: AIエージェントは、ファイル操作、テスト実行 (`pytest` 等)、パッケージインストールなどを、適切なDockerコンテナ内で自動的に行います。
  - 例: AIはテスト実行が必要な場合、自動的に `docker-compose run --rm test` (または同等の定義済みサービス) を実行し、結果を解釈します。
- **環境差異の吸収**: AIはDockerを使用することで、ローカル環境とCI/CD環境の差異を意識せずに開発を進めます。
- **CI/CDとの連携**: AIエージェントが作成し、PMが承認・マージしたコードは、DockerベースのCI/CDパイプラインによって自動的にテスト・ビルド・デプロイされます。

## 2. 実践的な開発フロー (PM指示 -> AI自律実行 -> PMレビュー -> 自動統合)

`project_management_guide.md` で定義されたチケット駆動開発とHuman-In-The-Loopの原則に基づき、以下のサイクルで開発を進めます。

1.  **計画フェーズ (PM)**: PMがタスクを定義し、GitHub Issueを作成します。Issueには、背景、目的、達成基準 (Acceptance Criteria) を明確に記述します。AIへの具体的な実装指示ではなく、「何を」達成したいかを記述します。
2.  **開発フェーズ (AI自律実行)**: AIエージェントがIssueを理解し、対応する機能ブランチを作成します。AIはTDDサイクル、コーディング、リファクタリングを自律的に行い、進捗をPMに報告します。PMは必要に応じて進捗を確認し、疑問点があればAIに質問したり、軌道修正のための高レベルな指示を与えたりします。
3.  **レビューフェーズ (PMによるPRレビュー)**: AIエージェントがIssueの達成基準を満たしたと判断したら、Pull Requestを作成します。PMはPRをレビューし、コード品質、テスト網羅性、要求仕様との整合性を確認します。修正が必要な場合は、PRにコメントを残し、AIに修正を依頼します。
4.  **統合フェーズ (PM承認 -> 自動化)**: PMがPRを承認すると、自動的に `main` ブランチにマージされます。マージをトリガーとしてCI/CDパイプラインが実行され、自動テスト、ビルド、デプロイが行われます。

### 2.1 CI/CDパイプラインのアプローチ (PM設定 & 自動実行)

CI/CDパイプラインはPMが設定・管理しますが、日々の実行はAIエージェントの開発活動 (具体的にはPMによるPR承認・マージ) によって自動的にトリガーされます。

1.  **パイプライン構成 (PM)**: PMはプロジェクト初期に、テスト、静的解析、ビルド、デプロイを含む基本的なCI/CDパイプラインをGitHub Actions等で構築します。
2.  **自動トリガー**: AIが開発しPMが承認したコードが `main` にマージされると、パイプラインが自動実行されます。
3.  **結果の監視 (PM & AI)**: パイプラインの実行結果 (成功/失敗) は自動的に通知されます。失敗した場合、PMまたはAI (設定による) が原因を調査し、必要な修正を行います (AIが修正する場合は新たなIssue/PRサイクルが発生)。
4.  **継続的改善 (PM)**: PMはパイプラインの効率や信頼性を定期的に見直し、必要に応じてステップの追加（セキュリティスキャン、パフォーマンステスト等）や設定の最適化を行います。

### 2.2 テスト駆動開発（TDD）の標準手順 (AI主体 & PMレビュー)

#### テストファイル構成

AIエージェントは、標準的なテストディレクトリ構造 (`tests/unit/`, `tests/integration/` など) に従ってテストファイルを自動的に配置します。

```
tests/
├── conftest.py          # 共通フィクスチャ (PMが設定、AIも利用)
├── unit/                # ユニットテスト
│   ├── test_module1.py  # PM指示 -> AI生成/編集
│   └── test_module2.py
├── integration/         # 統合テスト
│   └── test_feature_integration.py # PM指示 -> AI生成/編集
└── __init__.py
```

#### テストの種類と命名規則

AIエージェントは、ユニットテスト (`test_*.py`) と統合テスト (`test_*_integration.py`) を適切に区別し、標準的な命名規則に従ってテストを生成します。

#### テスト実行 (Docker経由での自動実行)

AIエージェントは、開発プロセス中に必要に応じてDockerコンテナ経由でテストを自動実行し、その結果を自身の判断やPMへの報告に利用します。

1.  **ユニットテスト**: 実装中やリファクタリング中にAIが適宜実行。
2.  **統合テスト**: 機能の実装がある程度完了した段階やPR作成前にAIが実行。
3.  **カバレッジ測定**: PR作成前にAIが実行し、カバレッジレポートを生成・添付することが推奨されます。

#### TDDの具体的な実装フロー (AI主体 & PMレビュー)

「1.2 開発プロセス」のTDDの項で記述した、AI主体のサイクルを実践します。

1.  AIがIssueに基づきテストケースを検討・生成 (失敗するテスト)。
2.  AIが実装コードを生成 (テスト通過)。
3.  AIがリファクタリングを実施。
4.  AIがカバレッジを確認し、必要ならテスト追加。
5.  AIが必要に応じて統合テストを追加・実行。
6.  AIがPRを作成し、テスト結果とカバレッジレポートを添付。
7.  PMがPRをレビュー (コード、テスト、結果)。
8.  PMが承認または修正指示。

## 3. 品質管理と測定 (PM監視 & AI活用による改善)

### 3.1 品質指標

PMは `quality_dashboard_guide.md` で定義された指標をダッシュボードで定期的に監視し、プロジェクト全体の健全性を評価します。AIエージェントもこれらの指標 (特にテストカバレッジや静的解析結果) を開発中に参照し、品質向上に役立てます。

### 3.2 継続的改善 (PM戦略 & AI実行)

- **品質ダッシュボードの活用**: PMはダッシュボードのトレンドからボトルネックや改善点を特定し、AIへの指示方針や利用するAIモデル/ツールの見直し、開発プロセス自体の改善戦略を立てます。
- **技術的負債の管理**: PMは技術的負債の特定と優先順位付けを行い、AIエージェントに計画的な解消を指示します。AIは負債解消のための具体的なリファクタリング案を提示・実行します。
- **自動化の推進**: PMはAIエージェントによる自動化が有効な領域 (例: 定型的なテスト生成、ドキュメント更新、依存関係更新など) を見極め、AIにその実行を委任、または支援ツールの導入を検討します。

## 4. ツールとリソース

### 4.1 推奨ツール

- **テストフレームワーク**: pytest
- **カバレッジ測定**: pytest-cov
- **静的解析**: flake8, pylint, mypy, bandit
- **CI/CD**: GitHub Actions
- **コンテナ化**: Docker, docker-compose
- **AIエージェント**: Cursor, Roo Code (Cline), その他MCP対応ツール
- **MCPサーバー**: 各種コミュニティ製サーバー
- **プロジェクト管理**: GitHub (Projects, Issues, PRs)
- **品質ダッシュボード**: Grafana, 静的HTML+JS, etc.

### 4.2 参考リソース

- [pytest ドキュメント](https://docs.pytest.org/)
- [GitHub Actions ドキュメント](https://docs.github.com/en/actions)
- [Docker ドキュメント](https://docs.docker.com/)
- [Model Context Protocol (MCP)](https://modelcontextprotocol.io/)
- (各AIエージェントのドキュメント)
- (本プロジェクト内の他のガイド: `project_management_guide.md`, `pytest_best_practices.md`, `quality_dashboard_guide.md`)
- [GitHub Flow](https://docs.github.com/ja/get-started/quickstart/github-flow) 